import streamlit as st
import subprocess
import json
import os
from pypdf import PdfReader

# --- Page Config ---
st.set_page_config(
    page_title="DebugSteller",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# --- Custom CSS (The "Hackathon Winning" Look) ---
st.markdown("""
<style>
    /* Hide Streamlit Chrome */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
    
    /* Remove Padding */
    .block-container {
        padding-top: 1rem;
        padding-bottom: 1rem;
    }
    
    /* Modern Fonts */
    html, body, [class*="css"] {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    
    /* Code Editor Font */
    .stTextArea textarea {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    }
    .stCode {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    }
    
    /* Gradient Header */
    .gradient-text {
        background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
        font-size: 3rem;
        margin-bottom: 0.5rem;
    }
    
    /* Custom Button Styling */
    div.stButton > button {
        width: 100%;
        background-color: #FF4B4B;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        font-weight: 600;
        border-radius: 0.5rem;
        transition: all 0.3s ease;
    }
    div.stButton > button:hover {
        background-color: #FF2B2B;
        box-shadow: 0 4px 12px rgba(255, 75, 75, 0.3);
    }
    
    /* Hide Anchor Links */
    .css-15zrgzn {display: none;}
    .css-10trblm {display: none;}
    a.anchor-link {display: none;}
</style>
""", unsafe_allow_html=True)

# --- Helper Functions ---
def parse_pdf(uploaded_file):
    try:
        reader = PdfReader(uploaded_file)
        text = ""
        for page in reader.pages:
            text += page.extract_text() + "\n"
        return text
    except Exception as e:
        st.error(f"Error parsing PDF: {e}")
        return None

def run_debugger(code_content):
    # Save to temp file
    with open("temp_source.py", "w") as f:
        f.write(code_content)
    
    # Run backend
    with st.spinner("Debugging & Optimizing... (This may take a minute)"):
        try:
            # Using python3 explicitly
            result = subprocess.run(
                ["python3", "main.py", "temp_source.py", "--model", "qwen2.5-coder:7b"],
                capture_output=True,
                text=True
            )
            return result
        except Exception as e:
            st.error(f"Execution Error: {e}")
            return None

def load_report():
    if os.path.exists("debug_report.json"):
        with open("debug_report.json", "r") as f:
            return json.load(f)
    return None

# --- Header ---
st.markdown('<h1 class="gradient-text">DebugSteller</h1>', unsafe_allow_html=True)
st.markdown("### AI-Powered Autonomous Debugging & Optimization Engine")
st.markdown("---")

left_col, right_col = st.columns([1, 1], gap="large")

# --- Left Column: Input ---
with left_col:
    st.subheader("Input Zone")
    
    input_method = st.radio("Source", ["Paste Code", "Upload File"], horizontal=True, label_visibility="collapsed")
    
    code_input = ""
    
    if input_method == "Paste Code":
        code_input = st.text_area("Code Editor", height=500, placeholder="Paste your buggy Python code here...")
    else:
        uploaded_file = st.file_uploader("Upload .py or .pdf", type=["py", "pdf"])
        if uploaded_file is not None:
            if uploaded_file.name.endswith(".pdf"):
                code_input = parse_pdf(uploaded_file)
                if code_input:
                    st.info("Extracted text from PDF. Please verify code structure below.")
                    code_input = st.text_area("Extracted Code", value=code_input, height=400)
            else:
                # .py file
                stringio = uploaded_file.getvalue().decode("utf-8")
                code_input = st.text_area("File Content", value=stringio, height=400)

    st.markdown("###") # Spacer
    run_btn = st.button("üöÄ Run Debugger", type="primary")

# --- Right Column: Output ---
with right_col:
    st.subheader("Output Zone")
    
    # Check if report exists from previous run to show something initially
    report = load_report()
    
    if run_btn and code_input:
        result = run_debugger(code_input)
        if result:
            # Reload report after run
            report = load_report()
            
            if not report:
                 st.error("Failed to load debug report.")
                 if result.stderr:
                    st.error(f"Backend Error: {result.stderr}")
    
    if report:
        tab1, tab2, tab3 = st.tabs(["Code Diff", "Analysis & Insights", "Raw Trace"])
        
        with tab1:
            st.caption("Original vs. Fixed Code")
            col_orig, col_fixed = st.columns(2)
            with col_orig:
                st.markdown("**Original**")
                st.code(report.get("original_code", ""), language="python")
            with col_fixed:
                st.markdown("**Fixed/Optimized**")
                st.code(report.get("repaired_code", ""), language="python")
        
        with tab2:
            st.caption("Optimization & Educational Notes")
            
            traces = report.get("traces", [])
            opt_report = report.get("optimization_report")
            original_code = report.get("original_code", "").strip()
            repaired_code = report.get("repaired_code", "").strip()
            
            # Check for Rejection (Scenario A)
            rejected_trace = next((t for t in traces if "Rejected" in t.get("status", "") or "REJECTED" in t.get("status", "").upper()), None)
            
            if rejected_trace:
                # Scenario A: Optimization Rejected
                st.error("üî¥ Optimization Rejected by Safety Guard")
                
                full_reason = rejected_trace.get("status", "").replace("Rejected: ", "")
                
                # Attempt to split traceback for better readability
                if "Traceback" in full_reason:
                    summary, traceback_part = full_reason.split("Traceback", 1)
                    st.markdown(f"**Reason:** {summary.strip()}")
                    st.markdown("üö® **Traceback (Error in LLM Patch):**")
                    st.code(f"Traceback{traceback_part}", language="bash")
                else:
                    st.markdown(f"**Reason:** {full_reason}")
                
                st.markdown("**Detailed Summary:** The system detected that the optimized code produced different output/side-effects than the original. The optimization was discarded to ensure correctness.")
                
                st.markdown("---")
                st.markdown("### Final Code")
                st.caption("‚ÑπÔ∏è The code below is the **Original, Unmodified Code** saved after the rejection.")
                st.code(repaired_code, language="python")
                
            elif original_code == repaired_code:
                # Scenario B: Code Already Optimal (No Change)
                st.info("‚ú® Code is Already Optimized")
                st.markdown("The system analyzed your code and found the time complexity is already optimal. No changes were applied to preserve logic.")
                
                st.markdown("### Final Code")
                st.code(repaired_code, language="python")
                
            else:
                # Scenario C: Optimization Successful (Code Changed & No Rejection)
                st.success("üöÄ Optimization Successful!")
                if opt_report:
                    # Only show complexity if it actually changed or is available
                    orig_comp = opt_report.get('original_complexity')
                    opt_comp = opt_report.get('optimized_complexity')
                    if orig_comp and opt_comp:
                         st.markdown(f"**Complexity Change:** `{orig_comp}` ‚ûù `{opt_comp}`")
                    
                    changes = opt_report.get("changes_summary", [])
                    if changes:
                        with st.expander("Detailed Improvements", expanded=True):
                            for change in changes:
                                st.markdown(f"- {change}")
                else:
                    st.markdown("Performance improvements and bug fixes were applied successfully.")

                st.markdown("### Final Optimized Code")
                st.code(repaired_code, language="python")

        with tab3:
            st.caption("Execution Trace")
            traces = report.get("traces", [])
            for trace in traces:
                status_icon = "‚úÖ" if trace.get("success") else "‚ùå"
                status_text = trace.get("status", "Attempted")
                
                with st.expander(f"{status_icon} Iteration {trace.get('iteration')}: {trace.get('error_type')} ({status_text})"):
                    st.write(f"**Strategy:** {trace.get('strategy')}")
                    st.write(f"**Patch:**")
                    st.code(trace.get('patch'), language="python")

        # Download Button
        st.markdown("---")
        fixed_code = report.get("repaired_code", "")
        if fixed_code:
            st.download_button(
                label="‚¨áÔ∏è Download Fixed Code",
                data=fixed_code,
                file_name="fixed_code.py",
                mime="text/x-python"
            )

    elif not run_btn:
        # Empty State
        st.info("Ready to debug. Enter code on the left and hit Run.")
        st.markdown("""
        **Features:**
        - üêû **Auto-Fix**: Detects and fixes runtime errors.
        - üöÄ **Optimization**: Improves time complexity (e.g., O(n^2) -> O(n)).
        - üõ°Ô∏è **Safety**: Verifies that optimization doesn't break logic.
        """)
